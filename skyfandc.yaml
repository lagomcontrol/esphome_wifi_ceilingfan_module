substitutions:
  name: skyfandc01
  friendly_name: SkyFan DC01

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  name_add_mac_suffix: true
  project:
    name: lagomcontrol.skyfandc_esphome
    version: "1.0"

# Define the board for the compiler
esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino
    
# Dashboard import if you want to adopt the device on your esphome dashboard
dashboard_import:
  package_import_url: github://lagomcontrol/skyfandc_esphome/skyfandc.yaml@main
  import_full_config: false

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_key

# Enable OTA
ota:
  - platform: esphome

# Enable Web server.
web_server:
  port: 80

# Enable WiFi and AP for captive portal
wifi:
  ssid: !secret ssid
  password: !secret password
  domain: !secret domain

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${friendly_name} ESP"
    password: !secret fallback_password

captive_portal:

uart:
  rx_pin: GPIO21
  tx_pin: GPIO20
  baud_rate: 9600 

status_led:
  pin: GPIO8

tuya:
  id: tuyamcu
  on_datapoint_update:  # <-- Moved inside tuya: section
    # Listen for power state changes from remote
    - sensor_datapoint: 1
      datapoint_type: bool
      then:
        - lambda: |-
            id(skyfandc_fan).make_call().set_state(x).perform();
    
    # Listen for speed changes from remote and remap
    - sensor_datapoint: 3
      datapoint_type: int
      then:
        - lambda: |-
            static const std::map<int, int> speed_map = {{1,1}, {6,2}, {2,3}, {3,4}, {4,5}, {5,6}};
            id(skyfandc_fan).make_call().set_speed(speed_map.at(x)).perform();
    
    # Listen for direction changes from remote
    - sensor_datapoint: 8
      datapoint_type: enum
      then:
        - lambda: |-
            id(skyfandc_fan).make_call()
              .set_direction((x == 0) ? fan::FanDirection::FORWARD : fan::FanDirection::REVERSE)
              .perform();

    # Light on/off from remote
    - sensor_datapoint: 15
      datapoint_type: bool
      then:
        - lambda: |-
            id(skip_light_update) = true;
            id(skyfan_light).make_call().set_state(x).perform();
        - delay: 500ms
        - lambda: 'id(skip_light_update) = false;'
    
    # Brightness from remote
    - sensor_datapoint: 16
      datapoint_type: int
      then:
        - lambda: |-
            id(skip_light_update) = true;
            id(skyfan_light).make_call().set_brightness(x / 5.0).perform();
        - delay: 500ms
        - lambda: 'id(skip_light_update) = false;'
    
    # Color temp from remote
    - sensor_datapoint: 19
      datapoint_type: enum
      then:
        - lambda: |-
            id(skip_light_update) = true;
            float mireds = (x == 0) ? 200.0 : (x == 1) ? 250.0 : 333.3;
            id(skyfan_light).make_call().set_color_temperature(mireds).perform();
        - delay: 500ms
        - lambda: 'id(skip_light_update) = false;'

select:
  # Hidden Tuya entity that actually control the hardware
  - platform: tuya
    id: color_temp_internal
    name: "${friendly_name} Color Temp Internal"
    internal: true
    enum_datapoint: 19
    options:
      0: 'Warm White (3000K)'
      1: 'Natural White (4000K)'
      2: 'Cool White (5000K)'

light:
  # Hidden Tuya entity that actually control the hardware
  - platform: tuya
    id: skyfan_light_internal
    name: "${friendly_name} Light Internal"
    internal: true
    switch_datapoint: 15
    dimmer_datapoint: 16
    min_value: 0
    max_value: 5

  - platform: cwww
    id: skyfan_light
    name: "${friendly_name} Light"
    cold_white: dummy_cold
    warm_white: dummy_warm
    cold_white_color_temperature: 5000 K
    warm_white_color_temperature: 3000 K
    constant_brightness: true
    default_transition_length: 0s
    
    on_turn_on:
      - lambda: |-
          if (id(skip_light_update)) return;
          id(tuyamcu).set_boolean_datapoint_value(15, true);
    
    on_turn_off:
      - lambda: |-
          if (id(skip_light_update)) return;
          id(tuyamcu).set_boolean_datapoint_value(15, false);
    
    on_state:
      - lambda: |-
          if (id(skip_light_update)) return;
          
          if (id(skyfan_light).current_values.is_on()) {
            auto brightness = id(skyfan_light).current_values.get_brightness();
            id(skyfan_light_internal).make_call().set_brightness(brightness).perform();
            
            auto color_temp_mireds = id(skyfan_light).current_values.get_color_temperature();
            int enum_value = (color_temp_mireds > 291) ? 2 : (color_temp_mireds > 225) ? 1 : 0;
            id(tuyamcu).set_enum_datapoint_value(19, enum_value);
          }

fan:
  - platform: template
    id: skyfandc_fan
    name: ${friendly_name} Fan
    speed_count: 6
    has_direction: true
    has_oscillating: false
    
    # Send commands from HA to Tuya with remapping
    on_speed_set:
      - lambda: |-
          int speeds[] = {0, 1, 6, 2, 3, 4, 5};
          id(tuyamcu).set_integer_datapoint_value(3, speeds[x]);

    on_turn_on:
      - lambda: 'id(tuyamcu).set_boolean_datapoint_value(1, true);'
    
    on_turn_off:
      - lambda: 'id(tuyamcu).set_boolean_datapoint_value(1, false);'
    
    on_direction_set:
      - lambda: |-
          id(tuyamcu).set_enum_datapoint_value(8, (x == fan::FanDirection::FORWARD) ? 0 : 1);

globals:
  - id: skip_light_update
    type: bool
    restore_value: no
    initial_value: 'false'

output:
  - platform: template
    id: dummy_warm
    type: float
    write_action:
      - lambda: 'return;'
  
  - platform: template
    id: dummy_cold
    type: float
    write_action:
      - lambda: 'return;'
